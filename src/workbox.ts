/// <reference lib="WebWorker" />

import { clientsClaim, RouteHandlerCallbackOptions } from "workbox-core";
import { precacheAndRoute, matchPrecache } from "workbox-precaching";
import { registerRoute } from "workbox-routing";

declare const self: ServiceWorkerGlobalScope;

// Make sure that the service worker activates immediately
clientsClaim();
self.skipWaiting();

// SPA Navigation Fallback, custom "network first" strategy implementation.
// This allows us to server index.html on all navigation requests, thus allowing
// the React router to handle the navigation.
registerRoute(
    ({ request }) => request.mode === "navigate" && request.method === "GET",
    navigateFallback,
    "GET"
);

// Cache all necessary assets with Workbox. Asset list is generated by webpack and injected here.
precacheAndRoute(self.__WB_MANIFEST);

// Network first fallback for SPA navigation requests. This is a custom implementation that checks
// the network first, and only if the network request fails, it will serve the index.html from the cache.
// This allows us to always serve the latest version of the app, while still allowing the app to work
// offline.
async function navigateFallback(args: RouteHandlerCallbackOptions) {
    const defaultFallbackUrl = "/index.html";
    let fetchedResponse: Response | undefined;

    // Adjust this timeout to your needs. If the network request takes longer than this, the
    // fallback will be served from the cache.
    const fetchTimeout = 2500;
    const controller = new AbortController();
    const signal = controller.signal;
    const cancelFetch = global.setTimeout(
        () => controller.abort(),
        fetchTimeout
    );

    try {
        console.debug(`Attempting to fetch ${args.request.url}.`);
        fetchedResponse = await fetch(args.request.url, { signal });
    } catch (error) {
        console.warn(`Fetch Error: ${error}`);
    }

    clearTimeout(cancelFetch);

    if (!fetchedResponse?.ok) {
        console.debug(
            `Failed to fetch ${args.request.url}. Serving ${defaultFallbackUrl} from cache.`
        );
        fetchedResponse = await matchPrecache(defaultFallbackUrl);
    }

    return fetchedResponse || Response.error();
}